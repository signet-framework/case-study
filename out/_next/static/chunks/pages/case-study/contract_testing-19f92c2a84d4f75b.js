(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[532],{6837:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/case-study/contract_testing",function(){return n(4174)}])},9369:function(e,t,n){"use strict";var i=n(5893);n(7294);let r={logo:(0,i.jsx)(i.Fragment,{children:(0,i.jsx)("img",{src:"/transparent-logo-horizontal-mn.svg",style:{maxHeight:"5rem"},alt:"logo"})}),project:{link:"https://github.com/signet-framework/"},docsRepositoryBase:"https://github.com/signet-framework/case-study",footer:{text:""},editLink:{text:null},feedback:{content:null},head:(0,i.jsx)(i.Fragment,{children:(0,i.jsx)("link",{rel:"icon",type:"image/ico",href:"/signet-favicon-transparent.ico"})})};t.Z=r},4174:function(e,t,n){"use strict";n.r(t);var i=n(5893),r=n(2673),s=n(3931),a=n(9369);n(9966);var o=n(1151);n(5675);let c={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,o.ah)(),e.components);return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)},pageOpts:{filePath:"pages/case-study/contract_testing.md",route:"/case-study/contract_testing",headings:[{depth:1,value:"Contract Testing",id:"contract-testing"},{depth:2,value:"Benefits of Contract Testing",id:"benefits-of-contract-testing"},{depth:2,value:"Drawbacks of Contract Testing",id:"drawbacks-of-contract-testing"},{depth:2,value:"Evaluating various forms of Contract Testing",id:"evaluating-various-forms-of-contract-testing"},{depth:3,value:"Consumer-driven",id:"consumer-driven"},{depth:3,value:"Provider-driven",id:"provider-driven"},{depth:3,value:"Spec-driven",id:"spec-driven"},{depth:2,value:"Existing Solutions",id:"existing-solutions"},{depth:3,value:"Pact",id:"pact"},{depth:3,value:"PactFlow",id:"pactflow"},{depth:3,value:"Karate",id:"karate"},{depth:3,value:"Specmatic",id:"specmatic"}],timestamp:169025636e4,pageMap:[{kind:"Meta",data:{index:{title:"Home",display:"hidden",type:"page"},"case-study-header-link":{title:"Case Study",type:"page",href:"/case-study"},quickstart:"Quickstart","case-study":{title:"Case Study"},about:{title:"About",type:"page"},contact:{title:"Contact â†—",type:"page",href:"https://github.com/signet-framework/",newWindow:!0}}},{kind:"MdxPage",name:"about",route:"/about"},{kind:"Folder",name:"case-study",route:"/case-study",children:[{kind:"Meta",data:{background:"Background",contract_testing:"Contract Testing",signet_framework:"Signet Framework",design_decisions:"Design Decisions"}},{kind:"Folder",name:"background",route:"/case-study/background",children:[{kind:"Meta",data:{monoliths_and_microservices:"Monoliths and Microservices",challenges_testing_microservices:"Challenges Testing Microservices"}},{kind:"MdxPage",name:"challenges_testing_microservices",route:"/case-study/background/challenges_testing_microservices"},{kind:"MdxPage",name:"monoliths_and_microservices",route:"/case-study/background/monoliths_and_microservices"}]},{kind:"MdxPage",name:"contract_testing",route:"/case-study/contract_testing"},{kind:"Folder",name:"design_decisions",route:"/case-study/design_decisions",children:[{kind:"Meta",data:{provider_verification:"Provider Verification",central_document_repository:"Central Document Repository",contract_generation:"Contract Generation"}},{kind:"MdxPage",name:"central_document_repository",route:"/case-study/design_decisions/central_document_repository"},{kind:"MdxPage",name:"contract_generation",route:"/case-study/design_decisions/contract_generation"},{kind:"MdxPage",name:"provider_verification",route:"/case-study/design_decisions/provider_verification"}]},{kind:"Folder",name:"signet_framework",route:"/case-study/signet_framework",children:[{kind:"Meta",data:{usecase:"Use Case"}},{kind:"MdxPage",name:"usecase",route:"/case-study/signet_framework/usecase"}]}]},{kind:"MdxPage",name:"case-study",route:"/case-study"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"quickstart",route:"/quickstart",children:[{kind:"Meta",data:{style_guide:"Style Guide",folders:"Folders and _meta.json",embed_image:"Embed an Image",mdx_with_react:"MDX with React"}},{kind:"MdxPage",name:"embed_image",route:"/quickstart/embed_image"},{kind:"MdxPage",name:"folders",route:"/quickstart/folders"},{kind:"MdxPage",name:"mdx_with_react",route:"/quickstart/mdx_with_react"},{kind:"MdxPage",name:"style_guide",route:"/quickstart/style_guide"}]},{kind:"MdxPage",name:"quickstart",route:"/quickstart"}],flexsearch:{codeblocks:!0},title:"Contract Testing"},pageNextRoute:"/case-study/contract_testing",nextraLayout:s.ZP,themeConfig:a.Z};function d(e){let t=Object.assign({h1:"h1",p:"p",strong:"strong",em:"em",h2:"h2",ul:"ul",li:"li",h3:"h3"},(0,o.ah)(),e.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.h1,{children:"Contract Testing"}),"\n",(0,i.jsxs)(t.p,{children:["Given two services that interact with each other, a ",(0,i.jsx)(t.strong,{children:"contract test"})," interrogates each service ",(0,i.jsx)(t.em,{children:"in isolation"})," to see if the two interfaces are compatible with each other.\nThe test relies on a document known as a ",(0,i.jsx)(t.strong,{children:"contract"})," that formally describes the interactions between the services."]}),"\n",(0,i.jsx)(t.p,{children:"Both services are individually tested to ensure that they conform to the contract.\nThe test fails if either service does not conform, indicating that the two services will not integrate correctly."}),"\n","\n","\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"TODO: diagram here illustrating an integration test"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"TODO: diagram here illustrating a contract test"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.strong,{children:"Q: should these be one side-by-side diagram?"})}),"\n",(0,i.jsx)(t.h2,{id:"benefits-of-contract-testing",children:"Benefits of Contract Testing"}),"\n",(0,i.jsx)(t.p,{children:"Contract tests relieve the burden of having to deploy multiple services together for integration testing.\nThey build confidence that the services will work correctly together, without requiring both teams to coordinate their testing or know how to run the other team's service."}),"\n",(0,i.jsx)(t.p,{children:"Not only that, but they also provide much faster feedback than integration and E2E tests.\nContract tests behave more like unit test or service tests, and can be run quickly, cheaply, and early on in the CI/CD pipeline.\nIn fact, they are lightweight enough that a developer could even run them locally before initiating the build processes."}),"\n",(0,i.jsx)(t.p,{children:"An added benefit of contract tests is that they isolate bugs with more specificity than most integration and E2E tests.\nBecause each interaction (e.g. an HTTP request and response pair) is enumerated in the contract, a failing test can report exactly which messages are missing or malformed."}),"\n",(0,i.jsx)(t.h2,{id:"drawbacks-of-contract-testing",children:"Drawbacks of Contract Testing"}),"\n",(0,i.jsx)(t.p,{children:"While contract tests reduce the need for broadly-scoped tests, they do not replace them entirely.\nE2E tests provide a high degree of confidence because they try to mimic production conditions to the greatest extent possible.\nContract tests have a more narrow focus--to test the compatibility of interfaces and catch breaking changes quickly.\nContract tests do not replicate production conditions such as latency, service unavailability, and high amounts of load."}),"\n",(0,i.jsxs)(t.p,{children:["Instead, contract tests reduce the ",(0,i.jsx)(t.em,{children:"quantity"})," of broadly-scoped tests that an application needs. Ideally, these tests can even be moved out of the CI/CD pipeline, and run in a periodic manner that is decoupled from the deployment life-cycle of any given team."]}),"\n",(0,i.jsx)(t.p,{children:"Another trade-off to consider is that implementing contract testing may require writing many new tests. Until there is sufficient coverage of a service's interface, that team cannot be confident that accidental breakages will be caught."}),"\n",(0,i.jsx)(t.h2,{id:"evaluating-various-forms-of-contract-testing",children:"Evaluating various forms of Contract Testing"}),"\n",(0,i.jsx)(t.p,{children:"There are many approaches to contract testing, and each vendor has a slightly different take on how it should be conducted. Methodologies are grouped into three categories according on how they determine the details of the contract. We will examine each of them in turn."}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Consumer-driven - the consumer service is the source of truth"}),"\n",(0,i.jsx)(t.li,{children:"Provider-driven - the provider service is the source of truth"}),"\n",(0,i.jsx)(t.li,{children:"Spec-driven - the source of truth is independent of either service's implementation"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"consumer-driven",children:"Consumer-driven"}),"\n",(0,i.jsxs)(t.p,{children:["In consumer-driven contract testing, the consumer service is implemented first.\nAfter the consumer team has implemented their side of the integration, they use unit tests to generate a consumer contract, which describes the expectations that the consumer service has of the provider service.\nThe consumer contract is then handed over to the provider team and they implement the provider's API to satisfy the needs of the consumer.\nAfter the provider API is implemented, the requests in the contract are ",(0,i.jsx)(t.em,{children:"replayed"})," against the API (a processed known as ",(0,i.jsx)(t.strong,{children:"provider verification"}),") and the responses are compared with those specified in the contract. If the provider service sends the correct response for each request, the test passes."]}),"\n",(0,i.jsx)(t.p,{children:"A significant advantage of the consumer-driven approach is that the contract describes exactly which parts of the provider API is being used by the consumer.\nThis gives the provider team insight into how they can evolve their API without breaking any consumers."}),"\n","\n",(0,i.jsx)(t.p,{children:"On the other hand, the consumer-driven approach has a critical drawback. It undermines independent deployability for consumer services.\nAfter generating the consumer contract, the consumer team must wait for the provider team to pull down the contract, spin up their service, and verify that it correctly implements the consumer's requirements.\nOnly if the provider passes verification can the consumer team proceed to deploying their service.\nIn the event that provider verification fails, either the consumer team must fix the issue and start the process over again, or they must wait for the provider team to update their API to satisfy the contract."}),"\n",(0,i.jsx)(t.p,{children:"In either case, the provider team must be involved any time the consumer team wants to deploy a new version of their service.\nTaking into account that microservices may have multiple external dependencies, consumer-driven contract testing requires significant cross-team coordination--placing a severe limitation on how quickly new software can be deployed."}),"\n",(0,i.jsx)(t.h3,{id:"provider-driven",children:"Provider-driven"}),"\n",(0,i.jsx)(t.p,{children:"Provider-driven contract testing is nearly the reverse of consumer-driven.\nThe provider service is implemented first, and a provider contract is generated that describes the provider's side of the integration.\nUsually the provider contract comes in the form of an API specification, other times the provider team distributes a test double which consumers can test against."}),"\n",(0,i.jsx)(t.p,{children:"The main benefit of a provider-driven approach is that it gives the provider team authority over what the integration looks like.\nWhether or not this makes sense depends on the organization and the roles of the services involved.\nOne situation where this is appropriate is when the provider has a large number of consumers, and it is impractical for the provider team to negotiate their API will all of them at once."}),"\n",(0,i.jsx)(t.p,{children:"In a provider-driven model, it is less clear whether contract testing will give the provider team insight into how their API is being consumed. The contract describes what the provider offers, not necessarily how consumers are using it. Provider-driven solutions commonly support the ability for writing consumer-specific test cases in the provider contract, but this demands substantial additional effort."}),"\n",(0,i.jsx)(t.h3,{id:"spec-driven",children:"Spec-driven"}),"\n",(0,i.jsx)(t.p,{children:"Spec-driven contract testing occurs when the API spec is defined separately from either service's implementation.\nUsually this means that the consumer and provider teams agree on the API spec ahead of time, before either service has implemented it."}),"\n",(0,i.jsx)(t.p,{children:'This approach flows naturally out of "Spec-first" API design, a practice where the provider team decides on a spec before writing the code, instead of documenting their implementation after it is completed.\nThis design philosophy is beneficial because it allows both the consumer and provider services to be implemented simultaneously.\nAs each service finishes implementation, it can be independently tested against the API spec to verify that it will integrate correctly with the other service.'}),"\n",(0,i.jsx)(t.p,{children:"Spec-driven contract testing is the most conducive to independent deployability.\nThe API spec is decided at the beginning, and both services can be tested against the spec independently.\nNeither team needs help from the other to test the integration.\nAs long as the both teams require every new version of their service to be tested for conformance to the spec, the deployment cycles of the two services can remain decoupled."}),"\n",(0,i.jsx)(t.h2,{id:"existing-solutions",children:"Existing Solutions"}),"\n",(0,i.jsx)(t.h3,{id:"pact",children:"Pact"}),"\n",(0,i.jsx)(t.p,{children:"Pact is the most well-known open-source option for contract testing.\nIt uses a purely consumer-driven model."}),"\n",(0,i.jsx)(t.p,{children:'Two notable characteristics of Pact are that it relies on client libraries for writing consumer contract tests, and it includes a backend application called a "broker."\nThe broker is responsible for managing contracts and describing the reasons for failed tests.\nIt also gives developers insight into which services are deployed where, and whether or not their service is safe to be deployed to a given environment.'}),"\n",(0,i.jsx)(t.p,{children:"We see two main challenges with Pact. The fact that it only works with a consumer-driven approach means that it does not maximize independent deployability. It also requires substantial investment in writing new unit tests."}),"\n",(0,i.jsx)(t.h3,{id:"pactflow",children:"PactFlow"}),"\n",(0,i.jsx)(t.p,{children:'The original creators of Pact have more recently come out with a paid Software-as-a-Service (SaaS) product called PactFlow.\nPactFlow builds on the foundation of Pact to provided a service they call "bidirectional" contract testing.\nBidirectional supports both spec-driven and provider-driven models by allowing the provider\'s API spec to be published before or after it has been tested against the provider service.'}),"\n",(0,i.jsx)(t.p,{children:"While PactFlow significantly improves upon the flexibility of Pact, it still requires substantial effort to add contract testing into the CI/CD workflow.\nConsumer teams still need to write new unit tests using a Pact client library, or else configure a third-party tool for generating the consumer contract.\nProvider teams likewise need to supply their own solution for testing the provider implementation against the API spec."}),"\n",(0,i.jsx)(t.h3,{id:"karate",children:"Karate"}),"\n",(0,i.jsx)(t.p,{children:"Karate is another popular open-source solution for contract testing.\nKarate takes a unique approach to the provider-driven model.\nRather than creating an API spec, the provider team uses Karate to generate a mock of the provider service.\nThe consumer team can then use the mock in their service tests to verify that the consumer will integrate correctly with the real provider.\nAlthough Karate does not use unit tests to generate a consumer contract, developer's still use Karate's DSL to manually program the provider mock to respond correctly to the specific requests from the consumer."}),"\n",(0,i.jsx)(t.h3,{id:"specmatic",children:"Specmatic"}),"\n",(0,i.jsx)(t.p,{children:"Specmatic is an open-source offering for spec-driven contract testing.\nA key feature of Specmatic is that it offers a way to generate the contract by automatically recording the interactions between the consumer and provider service.\nThis means that contract testing can be achieved with a significantly smaller startup cost--there is no need to write new unit tests to get up and running."}),"\n",(0,i.jsx)(t.p,{children:"Another characteristic of Specmatic is that it does not use a broker--contracts are stored in version control instead.\nWhile this comprises a simple solution for managing contracts, it loses out on some useful features that a broker can provide.\nFor instance, in order for a CI/CD pipeline to automatically gate a deployment based on what is currently deployed, significant effort must be expended to DIY this capability."})]})}t.default=(0,r.j)(c)}},function(e){e.O(0,[533,774,888,179],function(){return e(e.s=6837)}),_N_E=e.O()}]);
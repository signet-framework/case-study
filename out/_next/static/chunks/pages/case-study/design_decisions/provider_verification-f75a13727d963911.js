(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[354],{244:function(e,t,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/case-study/design_decisions/provider_verification",function(){return i(4434)}])},9369:function(e,t,i){"use strict";var o=i(5893);i(7294);let n={logo:(0,o.jsx)("span",{children:"Signet"}),project:{link:"https://github.com/signet-framework/"},docsRepositoryBase:"https://github.com/signet-framework/case-study"};t.Z=n},4434:function(e,t,i){"use strict";i.r(t);var o=i(5893),n=i(2673),r=i(3931),a=i(9369);i(9966);var s=i(1151);i(5675);let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,s.ah)(),e.components);return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)},pageOpts:{filePath:"pages/case-study/design_decisions/provider_verification.md",route:"/case-study/design_decisions/provider_verification",headings:[{depth:1,value:"Provider Verification",id:"provider-verification"},{depth:2,value:"What is it?",id:"what-is-it"},{depth:2,value:"How much should we do?",id:"how-much-should-we-do"},{depth:2,value:"How do we do it?",id:"how-do-we-do-it"},{depth:3,value:"Generate Unit Tests",id:"generate-unit-tests"},{depth:3,value:"Generate OpenAPI Specification from Code",id:"generate-openapi-specification-from-code"},{depth:3,value:"Black Box Test",id:"black-box-test"}],timestamp:1689815654e3,pageMap:[{kind:"Meta",data:{index:"Index",quickstart:"Quickstart",about:{title:"About",type:"page"},"case-study":"Case Study",contact:{title:"Contact â†—",type:"page",href:"https://github.com/signet-framework/",newWindow:!0}}},{kind:"MdxPage",name:"about",route:"/about"},{kind:"Folder",name:"case-study",route:"/case-study",children:[{kind:"Meta",data:{outline:"Outline",intro:"Introduction",background:"Background",design_decisions:"Design Decisions"}},{kind:"Folder",name:"background",route:"/case-study/background",children:[{kind:"MdxPage",name:"monoliths_and_microservices",route:"/case-study/background/monoliths_and_microservices"},{kind:"Meta",data:{monoliths_and_microservices:"Monoliths and Microservices"}}]},{kind:"Folder",name:"design_decisions",route:"/case-study/design_decisions",children:[{kind:"MdxPage",name:"provider_verification",route:"/case-study/design_decisions/provider_verification"},{kind:"Meta",data:{provider_verification:"Provider Verification"}}]},{kind:"MdxPage",name:"intro",route:"/case-study/intro"},{kind:"MdxPage",name:"outline",route:"/case-study/outline"}]},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"quickstart",route:"/quickstart",children:[{kind:"Meta",data:{folders:"Folders and _meta.json",embed_image:"Embed an Image",mdx_with_react:"MDX with React"}},{kind:"MdxPage",name:"embed_image",route:"/quickstart/embed_image"},{kind:"MdxPage",name:"folders",route:"/quickstart/folders"},{kind:"MdxPage",name:"mdx_with_react",route:"/quickstart/mdx_with_react"}]},{kind:"MdxPage",name:"quickstart",route:"/quickstart"}],flexsearch:{codeblocks:!0},title:"Provider Verification"},pageNextRoute:"/case-study/design_decisions/provider_verification",nextraLayout:r.ZP,themeConfig:a.Z};function c(e){let t=Object.assign({h1:"h1",h2:"h2",p:"p",h3:"h3"},(0,s.ah)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{children:"Provider Verification"}),"\n",(0,o.jsx)(t.h2,{id:"what-is-it",children:"What is it?"}),"\n",(0,o.jsx)(t.p,{children:"Consider a situation where the published consumer contract and provider specification are compatible, but the provider did not implement all the requirements defined in the specification. In this scenario, deploy guard should mark the provider and consumer as incompatible, but how does deploy guard know whether or not the provider has accurately implemented their specification? The answer is a process that we refer to as provider verification. Provider verification occurs when the provider tests their implementation against the published provider specification. The results of this verification are then integrated into deploy guard, adding an extra layer of confidence in the compatibility between consumer and provider."}),"\n",(0,o.jsx)(t.h2,{id:"how-much-should-we-do",children:"How much should we do?"}),"\n",(0,o.jsx)(t.p,{children:"Provider verification involves testing the provider and publishing the test results to the Signet broker. One approach is to push the responsibility of the provider test onto the developer, which gives them the freedom to use their preferred tools. They can then use the Signet CLI to publish the test results. Although this choice offers the developer more flexibility, it also increases the difficulty of contract testing. The developer would have to ensure that their tests accurately cover the requirements of the latest specification. Therefore, we decided to implement provider tests as a feature of Signet."}),"\n",(0,o.jsx)(t.h2,{id:"how-do-we-do-it",children:"How do we do it?"}),"\n",(0,o.jsx)(t.h3,{id:"generate-unit-tests",children:"Generate Unit Tests"}),"\n",(0,o.jsx)(t.p,{children:"One approach we considered was to to generate unit tests automatically from the OpenAPI Specification. The provider is verified if they pass the generated unit tests. The main advantage of this approach is its convenience in a new codebase, as it automates the process of writing unit tests for the specification. However, the code-invasive nature of this approach comes with a few downsides. Integrating our feature with existing testing frameworks is problematic, as it requires individual support for each framework. We would also need a way to ensure synchronization between unit tests and specifications, as developers can modify the unit tests in a way that inaccurately tests the specification. Therefore, we decided that providing support for this feature would be outside the current scope of Signet."}),"\n",(0,o.jsx)(t.h3,{id:"generate-openapi-specification-from-code",children:"Generate OpenAPI Specification from Code"}),"\n",(0,o.jsx)(t.p,{children:"Another approach involves generating an OpenAPI Specification directly from code. We could then compare the generated specification with the published one to ensure compatibility.  This approach is well-suited for an existing codebase, but the implementation would be complicated. Since tools for specification generation are specific to server frameworks, implementing this approach would require providing individual support for each framework. Therefore, we decided that providing support for this feature would be outside the current scope of Signet."}),"\n",(0,o.jsx)(t.h3,{id:"black-box-test",children:"Black Box Test"}),"\n",(0,o.jsx)(t.p,{children:"This approach involves performing black box testing. Black box testing is a testing technique in which the implementation details (code) of the tested software are unexposed to the tester. We can achieve this by simulating a mock consumer that utilizes the OpenAPI specification to send requests to the provider. If all the responses satisfy the requirements of the specification, then the provider is verified. The main benefit of this approach is that it's both language and platform agnostic. As a result, it's unnecessary to provide specific support for any testing or server framework. Therefore, we decided to implement this approach for provider verification."})]})}t.default=(0,n.j)(d)}},function(e){e.O(0,[774,533,888,179],function(){return e(e.s=244)}),_N_E=e.O()}]);
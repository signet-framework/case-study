{"/about":{"title":"About","data":{"":"This is the about page! This page is shown on the navbar."}},"/case-study/background/monoliths_and_microservices":{"title":"Monoliths and Microservices","data":{"":"There are two predominant styles of architecture currently in use by web applications.In a monolithic architecture, all of the application business logic runs in a single in-memory process. The different components of the application interact with each other through in-memory function and method calls. The all of the core functionality of the app resides in a centralized repository, and updates to any part of the app require the entire code base to be redeployed.In a microservices architecture, the application business logic consists of many separate services that interact with each other over the network. Each service is typically responsible for a single business domain, and it exposes an interface which allows other services to consume the functionality that the service provides.Monolithes are a sensible default architecture for many applications due to their simplicity, reliability, and lower development cost. Running all of the business logic as a single process eliminates a significant amount of complexity which is required to manage microservices. Despite this, microservices offer advantages that are very attractive to certain organizations.\nIndependent deployability - separating business domains into different services allows each service to evolve independently based on the changing needs of the organization. Decoupling the deployment of services allows each team to iterate on their service at their own pace, and reduces the need for them to coordinate with other teams when they want to release a new feature.\nSeparation of responsibility - developers are responsible for a distinct subset of the overall business logic of the application. They and their services should be allowed to remain ignorant of how other services are implemented, and only need to concern themselves with the interfaces that other services provide to them."}},"/case-study/design_decisions/provider_verification":{"title":"Provider Verification","data":{"":"","what-is-it#What is it?":"Consider a situation where the published consumer contract and provider specification are compatible, but the provider did not implement all the requirements defined in the specification. In this scenario, deploy guard should mark the provider and consumer as incompatible, but how does deploy guard know whether or not the provider has accurately implemented their specification? The answer is a process that we refer to as provider verification. Provider verification occurs when the provider tests their implementation against the published provider specification. The results of this verification are then integrated into deploy guard, adding an extra layer of confidence in the compatibility between consumer and provider.","how-much-should-we-do#How much should we do?":"Provider verification involves testing the provider and publishing the test results to the Signet broker. One approach is to push the responsibility of the provider test onto the developer, which gives them the freedom to use their preferred tools. They can then use the Signet CLI to publish the test results. Although this choice offers the developer more flexibility, it also increases the difficulty of contract testing. The developer would have to ensure that their tests accurately cover the requirements of the latest specification. Therefore, we decided to implement provider tests as a feature of Signet.","how-do-we-do-it#How do we do it?":"","generate-unit-tests#Generate Unit Tests":"One approach we considered was to to generate unit tests automatically from the OpenAPI Specification. The provider is verified if they pass the generated unit tests. The main advantage of this approach is its convenience in a new codebase, as it automates the process of writing unit tests for the specification. However, the code-invasive nature of this approach comes with a few downsides. Integrating our feature with existing testing frameworks is problematic, as it requires individual support for each framework. We would also need a way to ensure synchronization between unit tests and specifications, as developers can modify the unit tests in a way that inaccurately tests the specification. Therefore, we decided that providing support for this feature would be outside the current scope of Signet.","generate-openapi-specification-from-code#Generate OpenAPI Specification from Code":"Another approach involves generating an OpenAPI Specification directly from code. We could then compare the generated specification with the published one to ensure compatibility.  This approach is well-suited for an existing codebase, but the implementation would be complicated. Since tools for specification generation are specific to server frameworks, implementing this approach would require providing individual support for each framework. Therefore, we decided that providing support for this feature would be outside the current scope of Signet.","black-box-test#Black Box Test":"This approach involves performing black box testing. Black box testing is a testing technique in which the implementation details (code) of the tested software are unexposed to the tester. We can achieve this by simulating a mock consumer that utilizes the OpenAPI specification to send requests to the provider. If all the responses satisfy the requirements of the specification, then the provider is verified. The main benefit of this approach is that it's both language and platform agnostic. As a result, it's unnecessary to provide specific support for any testing or server framework. Therefore, we decided to implement this approach for provider verification."}},"/case-study/intro":{"title":"Intro","data":{"":"This will be the intro."}},"/case-study/outline":{"title":"Outline","data":{"":"","very-brief-intro#Very brief intro":"One small paragraph.","background-very-much-like-proposal#Background (very much like proposal)":"Automated testing\nIntro Microservices\nIn general\nIn context: problems more acute for microservices\nWhy unit tests are insufficient\n\n\nE2E Integration Testing\nChallenges that lead to wanting something like contract testing","contract-testing#Contract Testing":"Define terms\nConcepts\nConsumer-driven\nProvider-driven\nSpec-driven\n\n\nConnect it to the problem\nExisting Alternatives (where should this go?)\nPactflow\nSpecmatic\nOthers (SCC, Karate)","signet#Signet":"Use case / who is this for\nComparison with other solutions\nBroker\nDatabase\nWeb UI\nCLI\nConsumer Stuff\nContract generation\n\n\nProvider Stuff\nVerification\n\n\nDeployment\nAWS architecture","design-decisions--considerations#Design Decisions / Considerations":"Tie back to other alternatives too\nProvider verification through test\nConsumer contract generation through proxy\nFirst class support for automated CI/CD integration (webhooks)\nBroker vs Brokerless\nBoth consumer contract and provider spec\nSchema based vs Semantic\nUsing Pact Spec vs OpenAPI for consumer contract\nCompatibility with other frameworks","challenges--engineering-choices--tradeoffs#Challenges / Engineering Choices / Tradeoffs":"","architectural-decisions#Architectural Decisions":"Managed vs Self-hosted\nData model\nDeploy guard was a pain\nRelationship between contract and participant version\nNot having contract version\n\n\nDatabase type\nWhy SQL?\n\n\nAPI Access","how-we-built-it#How we built it":"Mountebank, swagger-mock-validator, Dredd","future-work#Future Work":"Roadmap\nLimitations\ngRPC\nEvent-driven"}},"/quickstart/embed_image":{"title":"Embed an Image","data":{"":"Store images in the assets folder and then embed them using normal markdown syntax.\n![](../../assets/example_diagram.png)\nRenders as:"}},"/":{"title":"Index","data":{"":"This is the main site index."}},"/quickstart/folders":{"title":"Folders and _meta.json","data":{"":"","display-names-and-ordering#Display Names and Ordering":"Each folder can have its own _meta.json. Use this file to set what name is displayed in the left nav menu for each file and the order in which the names appear.Example:\n{\n\"folders\": \"Folders and _meta.json\",\n\"embed_image\": \"Embed an Image\",\n\"mdx_with_react\": \"MDX with React\"\n}","folders-as-pages#Folders as Pages":"A folder can also be a clickable page in its own right; just add a .md file with the same name as the folder in the same directory that the folder is in.See the \"Quickstart\" page for an example of this setup."}},"/quickstart":{"title":"Quickstart","data":{"":"Every page should start with a first-level heading. The one for this page is # Quickstart which gets rendered as above.\nMake liberal use of subheadings (## Foo). These show up on the \"On This Page\" nav section to the right."}},"/quickstart/mdx_with_react":{"title":"MDX with React","data":{"":"Using .mdx files instead of vanilla markdown lets you embed JSX:\nlet a = 1;\n\nconsole.log(a);","component#Component":"","external-component#External Component":""}}}